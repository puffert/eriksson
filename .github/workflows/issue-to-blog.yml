name: Convert Issue to Blog Post

on:
  issues:
    types: [opened, labeled]

jobs:
  create-blog-post:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      issues: write
      
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        
      - name: Parse issue and create blog post
        uses: actions/github-script@v7
        with:
          script: |
            const issue = context.payload.issue;
            const body = issue.body || '';
            const labels = issue.labels || [];
            const labelNames = labels.map(l => l.name || l);
            
            // Check if this is a blog post issue
            // Either has the label, or has the required fields from the template
            const hasBlogLabel = labelNames.some(name => 
              name === 'publish' || name === 'blog-post'
            );
            
            // Parse the issue body (GitHub form format)
            // GitHub Forms format: ### Field Name\n\n[value]\n\n
            const parseField = (fieldName) => {
              // Try multiple patterns to handle different formats
              const patterns = [
                new RegExp(`### ${fieldName}\\s*\\n\\n([^#]+?)(?=\\n\\n###|$)`, 'is'),
                new RegExp(`### ${fieldName}\\s*\\n\\n([^#]+)`, 'i'),
                new RegExp(`\\*\\*${fieldName}\\*\\*:?\\s*\\n\\n([^#]+?)(?=\\n\\n\\*\\*|$)`, 'is'),
              ];
              
              for (const regex of patterns) {
                const match = body.match(regex);
                if (match && match[1]) {
                  return match[1].trim();
                }
              }
              return '';
            };
            
            const title = parseField('Post Title');
            const description = parseField('Description');
            const category = parseField('Category');
            const tagsStr = parseField('Tags') || '';
            const tags = tagsStr.split(',').map(t => t.trim()).filter(Boolean);
            const icon = parseField('Icon \\(optional\\)') || parseField('Icon') || 'üìÑ';
            const content = parseField('Content');
            const source = parseField('Source URL \\(optional\\)') || parseField('Source URL') || '';
            
            // Check if this looks like a blog post (has required fields)
            const isBlogPost = title && description && category && content;
            
            // If not a blog post and no label, skip
            if (!hasBlogLabel && !isBlogPost) {
              console.log('Issue does not appear to be a blog post. Skipping.');
              return;
            }
            
            // If it's a blog post but no label, add the publish label
            if (isBlogPost && !hasBlogLabel) {
              try {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  labels: ['publish']
                });
              } catch (error) {
                console.log('Could not add label (might not exist):', error.message);
              }
            }
            
            // Validate required fields
            if (!title || !description || !category || !content) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                body: `‚ùå Error: Missing required fields.\n\nParsed values:\n- Title: ${title || 'MISSING'}\n- Description: ${description || 'MISSING'}\n- Category: ${category || 'MISSING'}\n- Content: ${content ? 'Present' : 'MISSING'}\n\nPlease check the issue format and try again.`
              });
              return;
            }
            
            // Generate slug from title
            const slug = title.toLowerCase()
              .replace(/[^a-z0-9]+/g, '-')
              .replace(/^-+|-+$/g, '');
            
            if (!slug) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                body: `‚ùå Error: Could not generate a valid slug from the title. Please check the title format.`
              });
              return;
            }
            
            // Determine header image based on category
            const headerImages = {
              'Offensive Security': 'offensive',
              'Learning': 'AITesting',
              'News': 'news'
            };
            const headerImage = headerImages[category] || 'AITesting';
            
            // Create blog post content
            const date = new Date().toISOString().split('T')[0];
            
            // Escape YAML strings properly
            const escapeYaml = (str) => {
              if (!str) return '';
              // Replace newlines with spaces for single-line YAML fields
              return str.replace(/\n/g, ' ').replace(/"/g, '\\"').replace(/\\/g, '\\\\').trim();
            };
            
            const frontmatter = `---
title: "${escapeYaml(title)}"
description: "${escapeYaml(description)}"
pubDate: ${date}
category: "${escapeYaml(category)}"
icon: "${escapeYaml(icon)}"
tags: [${tags.map(t => `"${escapeYaml(t)}"`).join(', ')}]
image: "${headerImage}.png"
draft: false
---

`;
            
            const fullContent = frontmatter + content + 
              (source ? `\n\n---\n\n[Original Source](${source})` : '');
            
            // Create the file
            const filePath = `src/content/blog/${slug}.md`;
            
            // Check if file already exists
            try {
              await github.rest.repos.getContent({
                owner: context.repo.owner,
                repo: context.repo.repo,
                path: filePath,
              });
              
              // File exists, add comment and close issue
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                body: `‚ùå A blog post with this title already exists. Please choose a different title.`
              });
              return;
            } catch (error) {
              // File doesn't exist, proceed
            }
            
            // Get the default branch
            const { data: repo } = await github.rest.repos.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
            });
            
            // Create the blog post file
            try {
              await github.rest.repos.createOrUpdateFileContents({
                owner: context.repo.owner,
                repo: context.repo.repo,
                path: filePath,
                message: `üìù New blog post: ${title}`,
                content: Buffer.from(fullContent).toString('base64'),
                branch: repo.default_branch,
              });
              
              // Add comment to issue
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                body: `‚úÖ Blog post created successfully!\n\nView it at: https://vortexnode.net/blog/${slug}\n\nThe post will be live after the next deployment (usually within 2-3 minutes).`
              });
              
              // Close the issue
              await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                state: 'closed'
              });
            } catch (error) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                body: `‚ùå Error creating blog post: ${error.message}\n\nPlease check the GitHub Actions logs for more details.`
              });
              throw error;
            }
